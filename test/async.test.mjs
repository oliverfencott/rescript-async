// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "@dusty-phillips/rescript-zora/src/Zora.mjs";
import * as Zora$1 from "zora";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Async$ResinfoAsync from "../src/async.mjs";

function sleep(duration, fn) {
  setTimeout(fn, duration);
  
}

function sleepAsync(duration) {
  return Async$ResinfoAsync.make(function (param) {
              setTimeout(param, duration);
              
            });
}

function sleepPromise(duration) {
  return new Promise((function (resolve, param) {
                setTimeout((function (param) {
                        return resolve(undefined);
                      }), duration);
                
              }));
}

Zora$1.test("should run as callback", (function (t) {
        var init = {
          contents: false
        };
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Async$ResinfoAsync.run(Async$ResinfoAsync.make(function (param) {
                                                setTimeout(param, 1000);
                                                
                                              }), (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.is(init.contents, false, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.is(init.contents, true, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should run as promises", (function (t) {
        var init = {
          contents: false
        };
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                var __x = Async$ResinfoAsync.toPromise(Async$ResinfoAsync.make(function (param) {
                                          setTimeout(param, 1000);
                                          
                                        }));
                                __x.then(function (param) {
                                      resolve((init.contents = true, undefined));
                                      return Promise.resolve(undefined);
                                    });
                                
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.is(init.contents, false, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.is(init.contents, true, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should map values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Async$ResinfoAsync.map(Async$ResinfoAsync.make(function (param) {
                  setTimeout(param, 1000);
                  
                }), (function (param) {
                return true;
              }));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Async$ResinfoAsync.run(effect, (function (p) {
                                              return resolve((init.contents = p, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should flatMap values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Async$ResinfoAsync.flatMap(Async$ResinfoAsync.make(function (param) {
                  setTimeout(param, 1000);
                  
                }), (function (param) {
                return Async$ResinfoAsync.make(function (param) {
                            setTimeout(param, 1000);
                            
                          });
              }));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Async$ResinfoAsync.run(effect, (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should join values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Async$ResinfoAsync.join(Async$ResinfoAsync.map(Async$ResinfoAsync.make(function (param) {
                      setTimeout(param, 1000);
                      
                    }), (function (param) {
                    return Async$ResinfoAsync.unit(undefined);
                  })));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Async$ResinfoAsync.run(effect, (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should map, flatMap, join and run", (function (t) {
        var init = {
          contents: false
        };
        var effect = Async$ResinfoAsync.join(Async$ResinfoAsync.map(Async$ResinfoAsync.flatMap(Async$ResinfoAsync.map(Async$ResinfoAsync.flatMap(Async$ResinfoAsync.unit(undefined), (function (param) {
                                return Async$ResinfoAsync.make(function (param) {
                                            setTimeout(param, 1000);
                                            
                                          });
                              })), (function (param) {
                            return true;
                          })), (function (x) {
                        return Async$ResinfoAsync.map(Async$ResinfoAsync.make(function (param) {
                                        setTimeout(param, 1000);
                                        
                                      }), (function (param) {
                                      return x;
                                    }));
                      })), Async$ResinfoAsync.unit));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Async$ResinfoAsync.run(effect, (function (x) {
                                              return resolve((init.contents = x, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1000), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("Cancellable", (function (t) {
        var effect = Async$ResinfoAsync.join(Async$ResinfoAsync.map(Async$ResinfoAsync.flatMap(Async$ResinfoAsync.map(Async$ResinfoAsync.flatMap(Async$ResinfoAsync.unit(undefined), (function (param) {
                                return Async$ResinfoAsync.make(function (param) {
                                            setTimeout(param, 1000);
                                            
                                          });
                              })), (function (param) {
                            return true;
                          })), (function (x) {
                        return Async$ResinfoAsync.map(Async$ResinfoAsync.make(function (param) {
                                        setTimeout(param, 1000);
                                        
                                      }), (function (param) {
                                      return x;
                                    }));
                      })), Async$ResinfoAsync.unit));
        t.test("should run when not cancelled", (function (t) {
                var init = {
                  contents: false
                };
                return Zora.$$then(Promise.all([
                                new Promise((function (resolve, param) {
                                        Async$ResinfoAsync.Cancellable.run(effect, (function (x) {
                                                init.contents = x;
                                                return resolve(undefined);
                                              }));
                                        
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        t.test("should not run when not cancelled", (function (t) {
                var init = {
                  contents: false
                };
                var cancel = Async$ResinfoAsync.Cancellable.run(effect, (function (x) {
                        init.contents = x;
                        
                      }));
                return Zora.$$then(Promise.all([
                                Zora.$$then(sleepPromise(1500), (function (param) {
                                        Curry._1(cancel, undefined);
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(!init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        t.test("should run when cancelled after completion", (function (t) {
                var init = {
                  contents: false
                };
                var cancel = Async$ResinfoAsync.Cancellable.run(effect, (function (x) {
                        init.contents = x;
                        
                      }));
                return Zora.$$then(Promise.all([
                                Zora.$$then(sleepPromise(3500), (function (param) {
                                        Curry._1(cancel, undefined);
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        return Zora.done(undefined);
      }));

export {
  sleep ,
  sleepAsync ,
  sleepPromise ,
  
}
/*  Not a pure module */
