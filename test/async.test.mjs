// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "@dusty-phillips/rescript-zora/src/Zora.mjs";
import * as Zora$1 from "zora";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Resinfo_async from "../src/resinfo_async.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function sleep(duration, fn) {
  setTimeout(fn, duration);
  
}

function sleepAsync(duration) {
  return Resinfo_async.make(function (param) {
              setTimeout(param, duration);
              
            });
}

function sleepPromise(duration) {
  return new Promise((function (resolve, param) {
                setTimeout((function (param) {
                        return resolve(undefined);
                      }), duration);
                
              }));
}

Zora$1.test("should run as callback", (function (t) {
        var init = {
          contents: false
        };
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Resinfo_async.run(Resinfo_async.make(function (param) {
                                                setTimeout(param, 1000);
                                                
                                              }), (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.is(init.contents, false, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.is(init.contents, true, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should run as promises", (function (t) {
        var init = {
          contents: false
        };
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                var __x = Resinfo_async.toPromise(Resinfo_async.make(function (param) {
                                          setTimeout(param, 1000);
                                          
                                        }));
                                __x.then(function (param) {
                                      resolve((init.contents = true, undefined));
                                      return Promise.resolve(undefined);
                                    });
                                
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.is(init.contents, false, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.is(init.contents, true, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should map values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Resinfo_async.map(Resinfo_async.make(function (param) {
                  setTimeout(param, 1000);
                  
                }), (function (param) {
                return true;
              }));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Resinfo_async.run(effect, (function (p) {
                                              return resolve((init.contents = p, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should flatMap values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Resinfo_async.flatMap(Resinfo_async.make(function (param) {
                  setTimeout(param, 1000);
                  
                }), (function (param) {
                return Resinfo_async.make(function (param) {
                            setTimeout(param, 1000);
                            
                          });
              }));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Resinfo_async.run(effect, (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should join values", (function (t) {
        var init = {
          contents: false
        };
        var effect = Resinfo_async.join(Resinfo_async.map(Resinfo_async.make(function (param) {
                      setTimeout(param, 1000);
                      
                    }), (function (param) {
                    return Resinfo_async.unit(undefined);
                  })));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Resinfo_async.run(effect, (function (param) {
                                              return resolve((init.contents = true, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("should map, flatMap, join and run", (function (t) {
        var init = {
          contents: false
        };
        var effect = Resinfo_async.join(Resinfo_async.map(Resinfo_async.flatMap(Resinfo_async.map(Resinfo_async.flatMap(Resinfo_async.unit(undefined), (function (param) {
                                return Resinfo_async.make(function (param) {
                                            setTimeout(param, 1000);
                                            
                                          });
                              })), (function (param) {
                            return true;
                          })), (function (x) {
                        return Resinfo_async.map(Resinfo_async.make(function (param) {
                                        setTimeout(param, 1000);
                                        
                                      }), (function (param) {
                                      return x;
                                    }));
                      })), Resinfo_async.unit));
        return Zora.$$then(Promise.all([
                        new Promise((function (resolve, _reject) {
                                return Resinfo_async.run(effect, (function (x) {
                                              return resolve((init.contents = x, undefined));
                                            }));
                              })),
                        Zora.$$then(sleepPromise(500), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(1000), (function (param) {
                                t.ok(!init.contents, "async is still running");
                                return Zora.done(undefined);
                              })),
                        Zora.$$then(sleepPromise(2500), (function (param) {
                                t.ok(init.contents, "async finished running");
                                return Zora.done(undefined);
                              }))
                      ]), (function (param) {
                      return Zora.done(undefined);
                    }));
      }));

Zora$1.test("Cancellable", (function (t) {
        var effect = Resinfo_async.join(Resinfo_async.map(Resinfo_async.flatMap(Resinfo_async.map(Resinfo_async.flatMap(Resinfo_async.unit(undefined), (function (param) {
                                return Resinfo_async.make(function (param) {
                                            setTimeout(param, 1000);
                                            
                                          });
                              })), (function (param) {
                            return true;
                          })), (function (x) {
                        return Resinfo_async.map(Resinfo_async.make(function (param) {
                                        setTimeout(param, 1000);
                                        
                                      }), (function (param) {
                                      return x;
                                    }));
                      })), Resinfo_async.unit));
        t.test("should run when not cancelled", (function (t) {
                var init = {
                  contents: false
                };
                return Zora.$$then(Promise.all([
                                new Promise((function (resolve, param) {
                                        Resinfo_async.Cancellable.run(effect, (function (x) {
                                                init.contents = x;
                                                return resolve(undefined);
                                              }));
                                        
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        t.test("should not run when not cancelled", (function (t) {
                var init = {
                  contents: false
                };
                var cancel = Resinfo_async.Cancellable.run(effect, (function (x) {
                        init.contents = x;
                        
                      }));
                return Zora.$$then(Promise.all([
                                Zora.$$then(sleepPromise(1500), (function (param) {
                                        Curry._1(cancel, undefined);
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(!init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        t.test("should run when cancelled after completion", (function (t) {
                var init = {
                  contents: false
                };
                var cancel = Resinfo_async.Cancellable.run(effect, (function (x) {
                        init.contents = x;
                        
                      }));
                return Zora.$$then(Promise.all([
                                Zora.$$then(sleepPromise(3500), (function (param) {
                                        Curry._1(cancel, undefined);
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(500), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(1000), (function (param) {
                                        t.ok(!init.contents, "async is still running");
                                        return Zora.done(undefined);
                                      })),
                                Zora.$$then(sleepPromise(2500), (function (param) {
                                        t.ok(init.contents, "async finished running");
                                        return Zora.done(undefined);
                                      }))
                              ]), (function (param) {
                              return Zora.done(undefined);
                            }));
              }));
        return Zora.done(undefined);
      }));

var MyException = /* @__PURE__ */Caml_exceptions.create("Async.MyException");

Zora$1.test("can be constructed from a promise", (function (t) {
        t.test("it succeeds correctly", (function (t) {
                return new Promise((function (resolve, param) {
                              return Resinfo_async.run(Resinfo_async.fromPromise((function (param) {
                                                return sleepPromise(1000);
                                              }), (function (param) {
                                                return {
                                                        TAG: /* Ok */0,
                                                        _0: undefined
                                                      };
                                              }), (function (param) {
                                                return {
                                                        TAG: /* Error */1,
                                                        _0: undefined
                                                      };
                                              })), (function (res) {
                                            if (res.TAG === /* Ok */0) {
                                              t.ok(true, "returned correct result");
                                            } else {
                                              t.fail("returned incorrect result");
                                            }
                                            return resolve(undefined);
                                          }));
                            }));
              }));
        t.test("it fails correctly", (function (t) {
                return new Promise((function (resolve, param) {
                              return Resinfo_async.run(Resinfo_async.fromPromise((function (param) {
                                                return Promise.reject({
                                                            RE_EXN_ID: MyException
                                                          });
                                              }), (function (param) {
                                                return {
                                                        TAG: /* Ok */0,
                                                        _0: undefined
                                                      };
                                              }), (function (e) {
                                                return {
                                                        TAG: /* Error */1,
                                                        _0: e
                                                      };
                                              })), (function (res) {
                                            if (res.TAG === /* Ok */0) {
                                              t.fail("returned incorrect result");
                                            } else {
                                              t.ok(true, "returned correct result");
                                            }
                                            return resolve(undefined);
                                          }));
                            }));
              }));
        return Zora.done(undefined);
      }));

var Async;

var unit;

export {
  Async ,
  unit ,
  sleep ,
  sleepAsync ,
  sleepPromise ,
  MyException ,
  
}
/*  Not a pure module */
